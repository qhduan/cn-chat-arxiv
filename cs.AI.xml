<rss version="2.0"><channel><title>Chat Arxiv cs.AI</title><link>https://github.com/qhduan/cn-chat-arxiv</link><description>This is arxiv RSS feed for cs.AI</description><item><title>&#26412;&#30740;&#31350;&#22312;&#20132;&#25442;&#28436;&#31639;&#20013;&#32771;&#34385;&#20102;&#38598;&#21512;&#35774;&#22791;&#30340;&#21160;&#24577;&#21512;&#20316;&#34892;&#20026;&#65292;&#25552;&#20986;&#20102;&#20998;&#24067;&#24335;&#38598;&#20307;&#36807;&#31243;&#30340;&#25277;&#35937;&#34920;&#31034;&#65292;&#29992;&#20110;&#32534;&#31243;&#35745;&#31639;&#38598;&#20307;&#30340;&#34892;&#20026;&#12290;</title><link>http://arxiv.org/abs/2401.11212</link><description>&lt;p&gt;
&#22312;&#20132;&#25442;&#28436;&#31639;&#20013;&#32534;&#31243;&#20998;&#24067;&#24335;&#38598;&#20307;&#36807;&#31243;
&lt;/p&gt;
&lt;p&gt;
Programming Distributed Collective Processes in the eXchange Calculus. (arXiv:2401.11212v1 [cs.DC])
&lt;/p&gt;
&lt;p&gt;
http://arxiv.org/abs/2401.11212
&lt;/p&gt;
&lt;p&gt;
&#26412;&#30740;&#31350;&#22312;&#20132;&#25442;&#28436;&#31639;&#20013;&#32771;&#34385;&#20102;&#38598;&#21512;&#35774;&#22791;&#30340;&#21160;&#24577;&#21512;&#20316;&#34892;&#20026;&#65292;&#25552;&#20986;&#20102;&#20998;&#24067;&#24335;&#38598;&#20307;&#36807;&#31243;&#30340;&#25277;&#35937;&#34920;&#31034;&#65292;&#29992;&#20110;&#32534;&#31243;&#35745;&#31639;&#38598;&#20307;&#30340;&#34892;&#20026;&#12290;
&lt;/p&gt;
&lt;p&gt;

&lt;/p&gt;
&lt;p&gt;
&#26368;&#36817;&#30340;&#36235;&#21183;&#22914;&#29289;&#32852;&#32593;&#65288;IoT&#65289;&#25552;&#20986;&#20102;&#22312;&#20960;&#20046;&#25152;&#26377;&#29615;&#22659;&#20013;&#23494;&#38598;&#21644;&#22810;&#23610;&#24230;&#37096;&#32626;&#35745;&#31639;&#35774;&#22791;&#30340;&#24895;&#26223;&#12290;&#19968;&#20010;&#31361;&#20986;&#30340;&#24037;&#31243;&#25361;&#25112;&#22260;&#32469;&#30528;&#32534;&#31243;&#36825;&#31181;&#35745;&#31639;&#29983;&#24577;&#31995;&#32479;&#30340;&#38598;&#20307;&#33258;&#36866;&#24212;&#34892;&#20026;&#12290;&#36825;&#38656;&#35201;&#33021;&#22815;&#25429;&#25417;&#27010;&#24565;&#65288;&#21160;&#24577;&#21512;&#20316;&#35774;&#22791;&#32676;&#32452;&#65289;&#21644;&#38598;&#20307;&#20219;&#21153;&#65288;&#30001;&#21512;&#22863;&#32452;&#25191;&#34892;&#30340;&#32852;&#21512;&#27963;&#21160;&#65289;&#30340;&#25277;&#35937;&#12290;&#22312;&#36825;&#39033;&#24037;&#20316;&#20013;&#65292;&#25105;&#20204;&#32771;&#34385;&#19982;&#37051;&#23621;&#20132;&#20114;&#24182;&#20197;&#20960;&#20046;&#21516;&#27493;&#30340;&#24863;&#30693;-&#35745;&#31639;-&#20132;&#20114;&#24490;&#29615;&#25191;&#34892;&#30340;&#35774;&#22791;&#38598;&#21512;&#65292;&#20854;&#20013;&#35745;&#31639;&#30001;&#19968;&#20010;&#23558;&#24863;&#30693;&#20540;&#21644;&#20256;&#20837;&#28040;&#24687;&#26144;&#23556;&#21040;&#36755;&#20986;&#21644;&#20256;&#20986;&#28040;&#24687;&#30340;&#21333;&#20010;&#31243;&#24207;&#32473;&#20986;&#12290;&#20026;&#20102;&#25903;&#25345;&#25972;&#20010;&#35745;&#31639;&#38598;&#20307;&#30340;&#32534;&#31243;&#65292;&#25105;&#20204;&#25552;&#20986;&#20102;&#20998;&#24067;&#24335;&#38598;&#20307;&#36807;&#31243;&#30340;&#25277;&#35937;&#65292;&#23427;&#21487;&#20197;&#21516;&#26102;&#23450;&#20041;&#21512;&#22863;&#32452;&#30340;&#24418;&#25104;&#36923;&#36753;&#21644;&#23427;&#30340;&#38598;&#20307;&#20219;&#21153;&#12290;&#25105;&#20204;&#22312;&#20132;&#25442;&#28436;&#31639;&#20013;&#24418;&#24335;&#21270;&#20102;&#36825;&#31181;&#25277;&#35937;&#12290;
&lt;/p&gt;
&lt;p&gt;
Recent trends like the Internet of Things (IoT) suggest a vision of dense and multi-scale deployments of computing devices in nearly all kinds of environments. A prominent engineering challenge revolves around programming the collective adaptive behaviour of such computational ecosystems. This requires abstractions able to capture concepts like ensembles (dynamic groups of cooperating devices) and collective tasks (joint activities carried out by ensembles). In this work, we consider collections of devices interacting with neighbours and that execute in nearly-synchronised sense-compute-interact rounds, where the computation is given by a single program mapping sensing values and incoming messages to output and outcoming messages. To support programming whole computational collectives, we propose the abstraction of a distributed collective process, which can be used to define at once the ensemble formation logic and its collective task. We formalise the abstraction in the eXchange Calc
&lt;/p&gt;</description></item></channel></rss>